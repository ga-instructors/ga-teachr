jQuery ->
  fileUploadPreview = (input, $preview) ->
    if input.files && input.files[0]
      reader = new FileReader()
      reader.onload = (event) ->
        console.log(event.target.result)
        $preview.css({
          'background-image': "url(#{event.target.result})",
          'background-position': "50% 50%"
        })
      reader.readAsDataURL(input.files[0])

  $(document).on 'change', 'input#cohort_banner', (event) ->
    banner = $('.cohort__banner')
    fileUploadPreview(event.target, banner)

  if $('body#cohorts_show').length && !!location.hash
    $(location.hash.replace('#','#student_')).trigger('click')

  $(document).on 'dragstart', '#cohort_students', (event) ->
    $('#students_content').hide()
    $('#groups_ui').show()
  $(document).on 'dragend', '#cohort_students', (event) ->
    $('#students_content').show()
    $('#groups_ui li').removeClass('hover active')
    $('#groups_ui').hide()
  $(document).on 'dragover', '#groups_ui li', (event) ->
    $(this).siblings().removeClass('hover active')
    $(this).prevAll().addClass('hover')
    $(this).addClass('active')
    false
  $(document).on 'drop', '#groups_ui li', (event) ->
    groupCount = $(this).prevAll('li').length+1
    Turbolinks.visit(document.location.href.match(/(^[^#]*)/)+'/groups/new?groups_grouping[target_group_count]='+groupCount)

  ###computes control points given knots K, this is the brain of the operation###
  computeControlPoints = (K) ->
    p1 = new Array
    p2 = new Array
    n = K.length - 1

    ###rhs vector###

    a = new Array
    b = new Array
    c = new Array
    r = new Array

    ###left most segment###

    a[0] = 0
    b[0] = 2
    c[0] = 1
    r[0] = K[0] + 2 * K[1]

    ###internal segments###

    i = 1
    while i < n - 1
      a[i] = 1
      b[i] = 4
      c[i] = 1
      r[i] = 4 * K[i] + 2 * K[i + 1]
      i++

    ###right segment###

    a[n - 1] = 2
    b[n - 1] = 7
    c[n - 1] = 0
    r[n - 1] = 8 * K[n - 1] + K[n]

    ###solves Ax=b with the Thomas algorithm (from Wikipedia)###

    i = 1
    while i < n
      m = a[i] / b[i - 1]
      b[i] = b[i] - (m * c[i - 1])
      r[i] = r[i] - (m * r[i - 1])
      i++
    p1[n - 1] = r[n - 1] / b[n - 1]
    i = n - 2
    while i >= 0
      p1[i] = (r[i] - (c[i] * p1[i + 1])) / b[i]
      --i

    ###we have p1, now compute p2###

    i = 0
    while i < n - 1
      p2[i] = 2 * K[i + 1] - (p1[i + 1])
      i++
    p2[n - 1] = 0.5 * (K[n] + p1[n - 1])
    {
      p1: p1
      p2: p2
    }

  # ---
  # generated by js2coffee 2.1.0
